use std::collections::HashMap;

// Part 1
fn clamp<T>(val: T, min: T, max: T) -> T
where
    T: PartialOrd + Copy,
{
    if val < min {
        min
    } else if val > max {
        max
    } else {
        val
    }
}

fn findkey(startkey: char, dir: char) -> char {
    let key_to_coord: HashMap<char, (i32, i32)> = HashMap::from([
        ('1', (-1, -1)),
        ('2', (0, -1)),
        ('3', (1, -1)),
        ('4', (-1, 0)),
        ('5', (0, 0)),
        ('6', (1, 0)),
        ('7', (-1, 1)),
        ('8', (0, 1)),
        ('9', (1, 1)),
    ]);
    let coord_to_key: HashMap<(i32, i32), char> = HashMap::from([
        ((-1, -1), '1'),
        ((0, -1), '2'),
        ((1, -1), '3'),
        ((-1, 0), '4'),
        ((0, 0), '5'),
        ((1, 0), '6'),
        ((-1, 1), '7'),
        ((0, 1), '8'),
        ((1, 1), '9'),
    ]);
    let (mut x, mut y) = key_to_coord.get(&startkey).unwrap();
    if dir == 'U' {
        y -= 1;
    } else if dir == 'D' {
        y += 1;
    } else if dir == 'L' {
        x -= 1;
    } else if dir == 'R' {
        x += 1;
    } else {
        panic!("bad dir key: {}", dir);
    }
    x = clamp(x, -1, 1);
    y = clamp(y, -1, 1);

    *coord_to_key.get(&(x, y)).unwrap()
}

#[allow(unused)]
fn find_key(mut startkey: char, keypresses: &str) -> char {
    for c in keypresses.chars() {
        startkey = findkey(startkey, c)
    }
    startkey
}

// Part 2
fn next_key_part2(startkey: char, dir: char) -> char {
    #[allow(unused)]
    let grid = ["00100", "02340", "56789", "0ABC0", "00D00"];
    let coord = key_to_coord(startkey).unwrap();
    //println!("start coord: {:?}", coord);
    let (mut x, mut y) = coord;
    if dir == 'U' {
        y -= 1;
    } else if dir == 'D' {
        y += 1;
    } else if dir == 'L' {
        x -= 1;
    } else if dir == 'R' {
        x += 1;
    } else {
        panic!("bad dir key: {}", dir);
    }
    x = clamp(x, 0, 4);
    y = clamp(y, 0, 4);
    if let Some(nextkey) = coord_to_key((x, y)) {
        if nextkey == '0' {
            return startkey;
        } else {
            return nextkey;
        }
    } else {
        return startkey;
    }
}

fn key_to_coord(key: char) -> Option<(i32, i32)> {
    let grid = ["00100", "02340", "56789", "0ABC0", "00D00"];
    for (y, row) in grid.iter().enumerate() {
        for (x, button) in row.chars().enumerate() {
            if button == key {
                return Some((x as i32, y as i32));
            }
        }
    }
    None
}

fn coord_to_key(coord: (i32, i32)) -> Option<char> {
    let grid = ["00100", "02340", "56789", "0ABC0", "00D00"];
    let (x, y) = coord;
    Some(grid[y as usize].chars().nth(x as usize).unwrap())
}

fn find_key_part2(mut startkey: char, keypresses: &str) -> char {
    for k in keypresses.chars() {
        startkey = next_key_part2(startkey, k);
        //println!("nextkey: {}", startkey);
    }
    startkey
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test1() {
        let buttons2 = "UURD";
        let key = find_key('5', buttons2);
        assert_eq!(key, '6');
    }

    #[test]
    fn test1_part2() {
        let keypresses = "ULL";
        let mut startkey = '5';
        for k in keypresses.chars() {
            startkey = next_key_part2(startkey, k);
            println!("nextkey: {}", startkey);
        }
        assert_eq!('5', startkey);

        let keypresses2 = "RRDDD";
        println!("keypresses 2");
        for k in keypresses2.chars() {
            startkey = next_key_part2(startkey, k);
            println!("nextkey: {}", startkey);
        }
        assert_eq!('D', startkey);

        let keypresses3 = "LURDL";
        println!("keypresses 3");
        for k in keypresses3.chars() {
            startkey = next_key_part2(startkey, k);
            println!("nextkey: {}", startkey);
        }
        assert_eq!('B', startkey);

        let keypresses4 = "UUUUD";
        println!("keypresses 3");
        for k in keypresses4.chars() {
            startkey = next_key_part2(startkey, k);
            println!("nextkey: {}", startkey);
        }
        assert_eq!('3', startkey);
    }
}

#[allow(unused)]
fn part1() {
    let input = r"DLDRDDDLULDRRLUDDLDUURDRDUULDRDDRRLDLLUUDDLLRLRDRUURLUDURDDRURLUDDUULUURLLRRRRUDULUDLULLUURRLLRRURRUDUUURRLUUUDURDLLLDULDRLRDDDUDDUURLRRRURULLUDDUULDRRRDDLRLUDDRRDLRDURLRURUDDUULDDUUDDURRLUURRULRRLDLULLRLRUULDUDDLLLRDDULRUDURRDUUDUUDDUULULURDLUDRURDLUUDRDUURDDDRDRLDLDRURRLLRURURLLULLRRUULRRRRDLDULDDLRRRULRURRDURUDUUULDUUDRLDDLDUDDRULLUDUULRRRDRRDRDULDLURDDURLRUDLURLUDDDRLLURUUUUUUURUULDUUDDRLULRUDURRDLDUULLRLULLURDDDDDLRRDLRLLDDUDRRRDDURDLRRUDDUDLRRRDDURULRURRRLDRDUDLD
LRRDUDUUUDRRURRDUUULULUDDLLDRRRUDDUULRRDRUDRLLRLRULRRDUUDRLDURUDLLLDRRDLRLUUDRUDRRRUDRRRULDRRLLRDDDLLRDDRULRLLRUDRLLLULDLDDRDRUUUUUULURLLRUDRDRLLULLRUUURRDRULULUDLDURRUUDURLLUDRDLDDULUDLRDDRLRLURULDRURRRRURRDDUDRULUUUDDDRULRULDLLURUUULRDDLRUURLRLDLUULLURDRDDDUDDDRLDRDLLDRDDDDURLUUULDDRURULUDDURDRDRLULDULURDUURDRLLUUUULRULUUDRLLDDRRURUURLDLLRRRDLRURDDLDLDRLRRDLDURULDDLULRRRUUDLRDUURDURLURDDLDLRURLLLDRDULDDRUDDULDDRRLDLRDRDLDUUDLUULRLUDUUDUUUULDURULRRUDULURLRLDRLULLLDUDLLLRUDURDDDURLDDLRLRRDLUDLDDDDLULDRLDUUULDRRDDLRUULDLULUUURUDDRLDDDULRUDRURUURUUURRULRURDURLLRLLUULUULURDRLLUDDLU
LLDURDUDRLURUDRLRLUDDRRURDULULDDUDUULRRLRLRRDRDRDURRLRLURRLRUDULLUULLURUDDRLDDDRURLUUDLDURRDURDDLUULRDURRUUURLRRURRDRDRDURRRLULLDRUDLRUDURDRDDLLULLULRRUDULDDRDRRDLLLDLURLRDRDLUDDRLDDLDRULDURLLRLDRDLUDDDDLDUUDRLLRRRRLDDRRLRLURLLRLLUULLDUUDLRDRRRDRDLLDULLDRLDDUDRDDRURRDDLRDLRRUUDRRRRDURUULDRDDURLURRRRURRDRRULULURULUUUDRRRLDLLLDDRULRUDDURDRLDDRDLULLLRURUDRLRDDLDLRRRUURDURLDURRUUDDLRDRUUUURDLRLULRUUDRLDLULLULUURURDULUDUDRRRLLRLURLLDLRRURURRUDLUDDDDRDUDUDUUUULLDRDLLLLUUUUDRLRLUDURLLUDRUUDLLURUULDDDDULUUURLLDL
DLULLRDLRRLLLDLRRURRDRURDRUUULDDRLURURRDLRRULUUDDRLRRLDULRRUUDUULDDDUDLLDLURDRLLULLUUULLDURDRRRDDLRDUDRRRLRLDRRLRLULDDUDURRRLDLRULDULDDUDDRULDLDRDRDDRUDRUDURRRRUUDUDRLDURLDLRRUURRDDUDLLDUDRRURRLRRRRRLDUDDRLLLURUDRRUDRLRDUDUUUUUDURULLDUUDLRUUULDUUURURLUUDULDURUDDDLRRRDDRRDLRULLLRDDRLRLUULDUUULLLLDLRURLRRDURRLDLLLDURDLLUDDDLLDDURDDULURDRRRDDDLDDURRULUUDDLULLURULUULDLDDLUDRURURULUDDULRDRLDRRRUUUURUULDRLRRURRLULULURLLDRLRLURULRDDDULRDDLUR
RURRULLRRDLDUDDRRULUDLURLRRDDRDULLLUUDDDRDDRRULLLDRLRUULRRUDLDLLLRLLULDRLDDDLLDDULLDRLULUUUURRRLLDRLDLDLDDLUDULRDDLLRLLLULLUDDRDDUUUUDLDLRRDDRDLUDURRUURUURDULLLLLULRRLDRLRDLUURDUUDLDRURURLLDRRRLLLLRDLDURRLRRLLRUUDDUULLRLUDLRRRRRURUDDURULURRUULRDDULUUDUUDDRDDDDDUUUDDDRRLDDRRDDUUULDURLDULURDRDLLURDULRUDRUULUULLRRRRLRUUDDUDLDURURLRRRULRDRRUDDRDDRLRRRLRURRRUULULLLUULLLULLUDLRDLDURRURDLDLRDUULDRLLRRLDUDDUULULR";
    let lines = input.split('\n');
    let mut startkey = '5';
    for l in lines {
        startkey = find_key(startkey, l);
        println!("key: {}", startkey);
    }
}

fn part2() {
    println!("part2 keys:");
    let input = r"DLDRDDDLULDRRLUDDLDUURDRDUULDRDDRRLDLLUUDDLLRLRDRUURLUDURDDRURLUDDUULUURLLRRRRUDULUDLULLUURRLLRRURRUDUUURRLUUUDURDLLLDULDRLRDDDUDDUURLRRRURULLUDDUULDRRRDDLRLUDDRRDLRDURLRURUDDUULDDUUDDURRLUURRULRRLDLULLRLRUULDUDDLLLRDDULRUDURRDUUDUUDDUULULURDLUDRURDLUUDRDUURDDDRDRLDLDRURRLLRURURLLULLRRUULRRRRDLDULDDLRRRULRURRDURUDUUULDUUDRLDDLDUDDRULLUDUULRRRDRRDRDULDLURDDURLRUDLURLUDDDRLLURUUUUUUURUULDUUDDRLULRUDURRDLDUULLRLULLURDDDDDLRRDLRLLDDUDRRRDDURDLRRUDDUDLRRRDDURULRURRRLDRDUDLD
LRRDUDUUUDRRURRDUUULULUDDLLDRRRUDDUULRRDRUDRLLRLRULRRDUUDRLDURUDLLLDRRDLRLUUDRUDRRRUDRRRULDRRLLRDDDLLRDDRULRLLRUDRLLLULDLDDRDRUUUUUULURLLRUDRDRLLULLRUUURRDRULULUDLDURRUUDURLLUDRDLDDULUDLRDDRLRLURULDRURRRRURRDDUDRULUUUDDDRULRULDLLURUUULRDDLRUURLRLDLUULLURDRDDDUDDDRLDRDLLDRDDDDURLUUULDDRURULUDDURDRDRLULDULURDUURDRLLUUUULRULUUDRLLDDRRURUURLDLLRRRDLRURDDLDLDRLRRDLDURULDDLULRRRUUDLRDUURDURLURDDLDLRURLLLDRDULDDRUDDULDDRRLDLRDRDLDUUDLUULRLUDUUDUUUULDURULRRUDULURLRLDRLULLLDUDLLLRUDURDDDURLDDLRLRRDLUDLDDDDLULDRLDUUULDRRDDLRUULDLULUUURUDDRLDDDULRUDRURUURUUURRULRURDURLLRLLUULUULURDRLLUDDLU
LLDURDUDRLURUDRLRLUDDRRURDULULDDUDUULRRLRLRRDRDRDURRLRLURRLRUDULLUULLURUDDRLDDDRURLUUDLDURRDURDDLUULRDURRUUURLRRURRDRDRDURRRLULLDRUDLRUDURDRDDLLULLULRRUDULDDRDRRDLLLDLURLRDRDLUDDRLDDLDRULDURLLRLDRDLUDDDDLDUUDRLLRRRRLDDRRLRLURLLRLLUULLDUUDLRDRRRDRDLLDULLDRLDDUDRDDRURRDDLRDLRRUUDRRRRDURUULDRDDURLURRRRURRDRRULULURULUUUDRRRLDLLLDDRULRUDDURDRLDDRDLULLLRURUDRLRDDLDLRRRUURDURLDURRUUDDLRDRUUUURDLRLULRUUDRLDLULLULUURURDULUDUDRRRLLRLURLLDLRRURURRUDLUDDDDRDUDUDUUUULLDRDLLLLUUUUDRLRLUDURLLUDRUUDLLURUULDDDDULUUURLLDL
DLULLRDLRRLLLDLRRURRDRURDRUUULDDRLURURRDLRRULUUDDRLRRLDULRRUUDUULDDDUDLLDLURDRLLULLUUULLDURDRRRDDLRDUDRRRLRLDRRLRLULDDUDURRRLDLRULDULDDUDDRULDLDRDRDDRUDRUDURRRRUUDUDRLDURLDLRRUURRDDUDLLDUDRRURRLRRRRRLDUDDRLLLURUDRRUDRLRDUDUUUUUDURULLDUUDLRUUULDUUURURLUUDULDURUDDDLRRRDDRRDLRULLLRDDRLRLUULDUUULLLLDLRURLRRDURRLDLLLDURDLLUDDDLLDDURDDULURDRRRDDDLDDURRULUUDDLULLURULUULDLDDLUDRURURULUDDULRDRLDRRRUUUURUULDRLRRURRLULULURLLDRLRLURULRDDDULRDDLUR
RURRULLRRDLDUDDRRULUDLURLRRDDRDULLLUUDDDRDDRRULLLDRLRUULRRUDLDLLLRLLULDRLDDDLLDDULLDRLULUUUURRRLLDRLDLDLDDLUDULRDDLLRLLLULLUDDRDDUUUUDLDLRRDDRDLUDURRUURUURDULLLLLULRRLDRLRDLUURDUUDLDRURURLLDRRRLLLLRDLDURRLRRLLRUUDDUULLRLUDLRRRRRURUDDURULURRUULRDDULUUDUUDDRDDDDDUUUDDDRRLDDRRDDUUULDURLDULURDRDLLURDULRUDRUULUULLRRRRLRUUDDUDLDURURLRRRULRDRRUDDRDDRLRRRLRURRRUULULLLUULLLULLUDLRDLDURRURDLDLRDUULDRLLRRLDUDDUULULR";
    let lines = input.split('\n');
    let mut startkey = '5';
    for l in lines {
        startkey = find_key_part2(startkey, l);
        println!("key: {}", startkey);
    }
}
fn main() {
    part2();
}
